# LLM流式生成死循环检测方案设计

## 一、背景与问题定义

### 1.1 问题场景
在LLM流式生成过程中，偶尔会出现死循环现象，导致模型无限重复生成相同或相似的内容，无法正常完成任务。这种情况下需要及时中断生成，避免浪费资源和时间。

### 1.2 典型死循环类型
根据实际观察，死循环主要表现为以下三种类型：

**类型1：段落内容重复**
- 思考段（reasoning部分）出现部分文本以完全相同的模式反复出现
- 可能不换行，连续重复相同的句子或段落
- 例如："我需要分析这个问题。我需要分析这个问题。我需要分析这个问题。"

**类型2：有序列表重复**
- 思考段出现Markdown有序列表格式的重复
- 文本内容完全相同，但标号递增
- 例如："1. 分析需求\n2. 设计方案\n3. 分析需求\n4. 设计方案\n"
- 通常遵循语义边界（句号、分号、引号、换行符等）

**类型3：短序列循环**
- 较短序列的循环重复
- 例如："我需要思考思考思考思考..."（后面一直重复"思考"）
- 不局限于思考段部分，可能在任何位置出现

### 1.3 关键观察
- 死循环一般无法自己结束，一旦出现就会持续下去
- tool-calling部分不可能死循环
- 类型1和类型2仅出现在思考段部分
- 死循环的格式通常完全一致，不需要模糊匹配
- 唯一的例外是Markdown有序列表的标号会递增

## 二、检测方案设计

### 2.1 核心原则

**检测对象**：仅针对reasoningMessage（思考段累积文本）

原因：
- 类型1和类型2都发生在思考段内部
- 类型3虽然可能出现在任何位置，但主要在思考段
- 避免对正常文本内容造成误判

**检测时机**：基于reasoningMessage的字符数设置检查点，避免频繁检测影响性能

### 2.2 检查点设置

设置三个检查点，基于字符数（或token数）：

- **第1检查点**：2000字符（约800 tokens）
- **第2检查点**：3000字符（约1200 tokens）
- **第3检查点**：5000字符（约2000 tokens）

**设计理由**：
- 从2000字符开始检测，避免思考链前期可能复述用户要求而出现的合理重复
- 较晚开始可以避免用户提示词中已有的重复内容（如叠词）被误判
- 死循环通常不会自行结束，稍晚发现仍可及时中断
- 多个检查点可以覆盖不同阶段出现的死循环

### 2.3 通用周期检测逻辑

在介绍具体检测类型之前，先说明类型1和类型2共用的核心检测逻辑。

**周期检测函数**：

**输入参数**：
- 元素列表：可以是块列表（类型1）或行列表（类型2）
- 最大周期长度：默认50
- 最小重复元素数：默认6

**检测逻辑**：
1. 遍历可能的周期长度p，从1到min(最大周期长度, 列表长度//2)
2. 从列表末尾向前检查，统计连续满足"当前元素等于前面第p个元素"的数量
3. 如果连续重复的数量达到最小重复元素数阈值，则判定为周期循环
4. 返回检测结果（是否检测到循环、周期长度）

**示例**：
- 列表：["A", "B", "A", "B", "A", "B"]
- 周期长度p=2时，从末尾向前检查：
  - 索引5的"B" == 索引3的"B" ✓
  - 索引4的"A" == 索引2的"A" ✓
  - 索引3的"B" == 索引1的"B" ✓
  - 索引2的"A" == 索引0的"A" ✓
  - 连续重复数量=4，达到阈值，检测到循环

**优势**：
- 类型1和类型2共用同一套周期检测逻辑，避免代码重复
- 易于维护和优化
- 确保两种类型使用一致的检测标准
- 可扩展性强，未来添加其他周期检测类型可直接复用

### 2.4 分类型检测策略

#### 类型3：短序列循环检测

**检测时机**：第1检查点（2000字符）

**检测范围**：取最近200字符的文本片段（从1800到2000字符）

**检测逻辑**：
- 使用正则表达式检测连续重复的子串
- 匹配模式：至少2个字符的子串连续重复至少4次
- 例如："思考思考思考思考"会被检测到

**误判防范**：
- 最小重复单元长度设为2，避免单字符重复（如"....."）被误判
- 重复次数阈值设为4，避免正常重复（如"哈哈哈"）被误报
- 检测窗口小（200字符），即使不换行也能快速捕获

#### 类型1：段落内容重复检测

**检测时机**：第2检查点（3000字符）

**检测范围**：从上一个检查点（2000字符）到当前（3000字符）之间的文本片段

**检测逻辑**：

**步骤1：语义块分割**
- 以自然语言的常见边界符作为分隔点
- 分隔符包括：中文句号（。）、英文句号（.）、中文分号（；）、英文分号（;）、感叹号（！!）、问号（？?）、换行符（\n）
- 使用这些分隔符将文本分割成块列表
- 分隔符本身不保留在块中，因为块的内容才是重复检测的对象

**步骤2：调用通用周期检测**
- 调用通用周期检测函数，传入块列表
- 最大周期长度：50
- 最小重复元素数：6
- 如果检测到周期循环，则判定为类型1死循环

**示例**：
- 文本："今天天气真好。我们出去玩吧！今天天气真好。我们出去玩吧！"
- 分割为块：["今天天气真好", "我们出去玩吧", "今天天气真好", "我们出去玩吧"]
- 调用周期检测，周期长度为2时，连续重复2次（共4个块），满足阈值，触发检测

**优势**：
- 不依赖换行，能捕捉到行内重复的句子或短语
- 块的数量远少于字符数，计算开销小
- 块边界贴合自然语言，减少将合理重复误判为死循环的可能

#### 类型2：有序列表重复检测

**检测时机**：第2检查点（3000字符）

**检测范围**：从上一个检查点（2000字符）到当前（3000字符）之间的文本片段

**检测逻辑**：

**步骤1：按行分割**
- 使用换行符将文本分割成行列表

**步骤2：行标准化**
- 对每一行进行检查，如果行首匹配有序列表标号模式（如"1. "、"2. "、"10. "等）
- 去除标号，保留后续内容
- 如果行首不匹配有序列表标号，则保留原行

**步骤3：调用通用周期检测**
- 调用通用周期检测函数，传入标准化后的行列表
- 最大周期长度：50
- 最小重复元素数：6
- 如果检测到周期循环，则判定为类型2死循环

**示例**：
- 文本："1. 分析需求\n2. 设计方案\n3. 分析需求\n4. 设计方案\n5. 分析需求\n6. 设计方案"
- 标准化后：["分析需求", "设计方案", "分析需求", "设计方案", "分析需求", "设计方案"]
- 调用周期检测，周期长度为2时，连续重复3次（共6行），满足阈值，触发检测

**优势**：
- 有序列表通常以换行分隔，基于行的检测非常有效
- 标准化处理去除了标号差异，只关注内容重复
- 与类型1检测并行运行，互不干扰

#### 尾部二次检查

**检测时机**：第3检查点（5000字符）

**检测范围**：从上一个检查点（3000字符）到当前（5000字符）之间的文本片段

**检测逻辑**：
- 重复执行类型1和类型2的检测逻辑
- 目的是防止死循环在长文本的尾部才出现

**设计理由**：
- 对于极端长的思考内容，死循环可能在后期才出现
- 增加一个检查点可以覆盖这种情况
- 虽然较晚发现问题，但能更好地平衡检查逻辑的性能开销

### 2.5 检测流程总结

1. 每次接收到reasoning chunk时，将其追加到reasoningMessage
2. 检查reasoningMessage的当前长度是否达到某个检查点
3. 如果达到检查点且该检查点尚未执行过检测，则执行对应的检测逻辑
4. 标记该检查点已检测，避免重复触发
5. 如果任一检测逻辑发现死循环，立即中断流式生成

## 三、检测逻辑架构

### 3.1 检测逻辑层次结构

```
死循环检测器
├── 类型3检测（短序列循环）
│   └── 正则匹配检测
└── 周期检测（类型1和类型2共用）
    ├── 类型1检测（段落重复）
    │   ├── 语义块分割
    │   └── 调用通用周期检测
    └── 类型2检测（有序列表重复）
        ├── 按行分割
        ├── 行标准化
        └── 调用通用周期检测
```

### 3.2 代码复用优势

**避免重复实现**：
- 周期检测逻辑只实现一次
- 类型1和类型2都调用同一个函数
- 减少代码量，降低维护成本

**一致性保证**：
- 确保类型1和类型2使用相同的周期检测标准
- 参数调整只需修改一处
- 检测结果具有可比性

**易于扩展**：
- 如果未来需要添加其他类型的周期检测（如基于词的周期检测）
- 可以直接复用通用周期检测函数
- 只需实现新的分割和标准化逻辑

## 四、集成方案

### 4.1 检测器类设计

创建一个独立的检测器类，负责所有死循环检测逻辑。

**核心职责**：
- 维护检测状态（已检查的检查点）
- 提供检测接口，接收reasoningMessage文本
- 根据文本长度触发相应的检测逻辑
- 返回检测结果（是否发现死循环、死循环类型、详细信息）

**配置参数**：
- 检查点阈值：默认[2000, 3000, 5000]
- 短序列检测窗口大小：默认200字符
- 最小重复单元长度：默认2字符
- 最小重复次数：默认4次
- 最小周期块/行数：默认6
- 最大周期长度：默认50

**主要方法**：
- 检测方法：每次接收到reasoning chunk时调用，传入当前的reasoningMessage
- 重置方法：每次新的API请求开始时调用，清空检测状态

**内部方法**：
- 通用周期检测方法：接收元素列表，返回是否检测到周期循环
- 类型3检测方法：使用正则匹配检测短序列循环
- 类型1检测方法：语义块分割 + 调用通用周期检测
- 类型2检测方法：按行分割 + 行标准化 + 调用通用周期检测

### 4.2 在Task.ts中的集成

**集成位置**：Task.ts中的流式处理循环

**集成点1：初始化检测器**
- 在流式处理开始前，创建检测器实例
- 位置：在tokenCounter初始化之后

**集成点2：reasoning chunk处理**
- 在reasoning chunk的case分支中，将chunk.text追加到reasoningMessage后
- 调用检测器的检测方法，传入当前的reasoningMessage
- 如果检测到死循环，记录错误日志并调用abortStream中断流式生成
- 位置：在reasoningMessage += chunk.text之后，在await this.say之前

**集成点3：重置检测器**
- 在每次新的API请求开始时，调用检测器的重置方法
- 位置：在streamingToolCallIndices.clear()之后

### 4.3 错误处理

当检测到死循环时：

1. 记录详细的错误日志，包括：
   - 死循环类型（类型1/2/3）
   - 检测到的位置（字符数范围）
   - 重复的模式描述

2. 调用abortStream方法中断流式生成
   - 取消原因：streaming_failed
   - 错误消息：向用户说明检测到死循环

3. 任务会自动触发重试机制（现有逻辑）
   - 如果是偶发的死循环，重试可能成功
   - 如果是模型本身的问题，可能需要人工干预

## 五、性能优化

### 5.1 检测开销控制

**检查点机制**：
- 仅在三个检查点触发检测，不对每个chunk都检测
- 避免频繁检测带来的性能开销

**检测范围限制**：
- 类型3检测：仅检查最近200字符
- 类型1/2检测：仅检查1000字符区间（2000-3000或3000-5000）
- 每次检测的文本量有限

**算法复杂度**：
- 正则匹配：O(n)，n为窗口大小（200字符）
- 周期检测：O(m * p_max)，m为块/行数（通常<100），p_max为最大周期长度（50）
- 整体开销可忽略不计

### 5.2 内存优化

**状态管理**：
- 检测器只保存必要的检查点状态（已检查的阈值）
- 不缓存完整的reasoningMessage历史
- 每次检测时传入当前的reasoningMessage即可

**避免重复计算**：
- 标记已检查的检查点，避免重复触发
- 检测完成后立即释放临时数据

### 5.3 可配置性

**参数可调**：
- 所有阈值和参数都可通过配置调整
- 可根据实际使用情况优化参数
- 支持不同模型使用不同参数

**灵活启用/禁用**：
- 可以通过配置启用或禁用死循环检测
- 便于调试和性能对比

## 六、误判防范

### 6.1 阈值设置

**重复次数阈值**：
- 类型3：重复次数≥4次，避免正常重复（如"哈哈哈"）被误报
- 类型1/2：连续重复块/行数≥6，避免短小重复被误判

**周期长度限制**：
- 最大周期长度设为50，避免检测过长无意义的周期
- 避免将长文本中的偶然相似误判为循环

### 6.2 边界情况处理

**用户输入中的重复**：
- 检测从2000字符开始，避免用户提示词中的重复影响
- 如果用户提示词本身包含大量重复，不会触发早期检测

**代码块特殊处理**：
- 代码中可能包含重复行（如循环结构）
- 可通过检测上下文（如是否在代码块标记内）暂时禁用检测
- 或提高阈值，减少误判

**格式化内容**：
- 不对空格等格式字符进行标准化
- 避免将格式化生成内容误判为死循环
- 只进行完整匹配，不进行模糊匹配

### 6.3 白名单机制

**可考虑添加白名单**：
- 对于已知的合理重复模式，可以加入白名单
- 例如某些特定的格式化输出
- 但目前方案中暂不实现，先观察实际效果

## 七、测试策略

### 7.1 单元测试

**测试文件**：src/utils/__tests__/deadLoopDetector.spec.ts

**测试用例**：

**类型3测试**：
- 短序列循环检测（如"思考思考思考思考"）
- 刚好达到阈值的情况
- 刚好未达到阈值的情况
- 单字符重复不应触发
- 正常重复（如"哈哈哈"）不应触发

**类型1测试**：
- 段落重复检测（不换行场景）
- 段落重复检测（换行场景）
- 刚好达到阈值的情况
- 刚好未达到阈值的情况
- 不同语义边界符的分割
- 正常列举不应触发

**类型2测试**：
- 有序列表重复检测
- 标号递增但内容相同
- 刚好达到阈值的情况
- 刚好未达到阈值的情况
- 不同标号格式的标准化
- 正常列表不应触发

**通用周期检测测试**：
- 不同周期长度的检测
- 边界情况（刚好达到阈值、刚好未达到）
- 空列表处理
- 单元素列表处理

**边界测试**：
- 检查点边界情况
- 空文本处理
- 极短文本处理
- 极长文本处理

**误判测试**：
- 用户提示词中的重复
- 代码块中的重复
- 格式化内容
- 正常的列举和强调

### 7.2 集成测试

**测试场景**：
- 在Task的测试中模拟reasoning流式生成
- 验证检测器能正确触发abortStream
- 验证错误日志正确记录
- 验证用户看到友好的错误提示
- 验证重试机制正常工作

### 7.3 实际使用验证

**监控指标**：
- 死循环检测触发频率
- 误判率（用户反馈）
- 检测延迟（从死循环开始到被检测到的字符数）
- 性能影响（检测耗时）

**参数调优**：
- 根据实际使用情况调整阈值
- 根据误判情况优化检测逻辑
- 根据性能影响调整检查点

## 八、实现优先级

### 8.1 第一阶段：基础功能

**高优先级**：
1. 实现检测器类的基本框架
2. 实现通用周期检测方法
3. 实现类型3检测（短序列循环）
   - 最简单，最容易发现
   - 正则匹配实现简单
   - 可以快速验证集成方案

4. 在Task.ts中集成检测器
   - 初始化检测器
   - 在reasoning chunk处理中调用检测
   - 实现错误处理和中断逻辑

5. 编写基础单元测试
   - 类型3的测试用例
   - 通用周期检测的测试用例
   - 集成测试

### 8.2 第二阶段：完善检测

**中优先级**：
1. 实现类型2检测（有序列表重复）
   - 基于行的检测，相对简单
   - 标准化逻辑清晰
   - 可以覆盖常见的列表重复场景
   - 复用通用周期检测方法

2. 实现类型1检测（段落重复）
   - 基于语义块的检测
   - 需要仔细设计边界符
   - 可以处理不换行的重复
   - 复用通用周期检测方法

3. 完善单元测试
   - 类型1和类型2的测试用例
   - 边界情况测试
   - 误判测试

### 8.3 第三阶段：优化增强

**低优先级**：
1. 实现尾部二次检查
   - 第3检查点的检测逻辑
   - 覆盖极端长文本的尾部死循环

2. 添加配置支持
   - 支持通过配置文件调整参数
   - 支持启用/禁用检测

3. 性能优化
   - 根据实际使用情况优化算法
   - 减少不必要的计算

4. 监控和日志
   - 添加详细的检测日志
   - 收集检测统计信息

## 九、注意事项

### 9.1 实现细节

**不要标准化空格**：
- 避免将格式化内容误判为死循环
- 保持原始格式，只进行完整匹配

**完整匹配即可**：
- 不需要模糊匹配，降低误判率
- 死循环的格式通常完全一致

**考虑中英文差异**：
- 语义边界符需要同时支持中英文
- 句号、分号、感叹号、问号都要考虑中英文版本

### 9.2 代码块处理

**潜在问题**：
- 如果reasoning包含代码块，可能包含重复行
- 例如循环结构、重复的函数调用等

**处理方案**：
- 方案1：检测是否在代码块标记内（如```），如果是则跳过检测
- 方案2：提高阈值，减少误判
- 方案3：暂时不处理，先观察实际效果

### 9.3 用户输入影响

**问题**：
- 用户提示词可能包含重复内容
- 例如用户输入了多个叠词，或存在错误的多次输入

**处理方案**：
- 检测从2000字符开始，避免早期误判
- 如果用户提示词很长且包含重复，可能需要调整起始阈值
- 可以考虑在预处理阶段标记用户输入，检测时跳过

### 9.4 模型差异

**不同模型的行为**：
- 不同模型可能产生不同类型的死循环
- 某些模型可能更容易产生某种类型的死循环

**处理方案**：
- 参数可配置，支持不同模型使用不同参数
- 收集不同模型的死循环案例，针对性优化

## 十、预期效果

### 10.1 准确率

**预期**：
- 能够检测到大部分典型的死循环情况
- 类型3检测准确率：>95%
- 类型2检测准确率：>90%
- 类型1检测准确率：>85%

**原因**：
- 类型3最简单，正则匹配非常准确
- 类型2基于行检测，列表格式规范
- 类型1基于语义块，边界判断可能不够精确

### 10.2 误判率

**预期**：
- 误判率：<5%
- 主要误判来源：代码块中的重复、格式化内容

**改进方向**：
- 根据实际误判案例优化检测逻辑
- 添加白名单机制
- 提高阈值

### 10.3 性能影响

**预期**：
- 检测开销：<1ms每次检测
- 对整体生成性能的影响：<0.1%
- 用户无感知

**原因**：
- 仅在三个检查点触发
- 每次检测的文本量有限
- 算法复杂度低

### 10.4 检测延迟

**预期**：
- 从死循环开始到被检测到的延迟：<1000字符
- 大部分情况在200-500字符内被检测到

**原因**：
- 类型3在2000字符后立即检测（窗口200字符）
- 类型1/2在3000字符后检测（区间1000字符）
- 死循环一旦开始就会持续，很快就能被检测到

## 十一、后续优化方向

### 11.1 智能检测

**基于机器学习**：
- 训练模型识别死循环模式
- 可以处理更复杂的死循环情况
- 但需要大量标注数据

**基于统计**：
- 统计历史死循环案例
- 自动调整检测参数
- 提高检测准确率

### 11.2 上下文感知

**考虑上下文**：
- 根据上下文判断是否为合理的重复
- 例如代码块中的重复、格式化输出等
- 减少误判

**多维度检测**：
- 不仅检测文本重复，还检测语义重复
- 使用embedding计算相似度
- 可以检测到改写的重复

### 11.3 自适应阈值

**动态调整**：
- 根据模型、任务类型动态调整阈值
- 根据历史检测情况动态调整阈值
- 提高检测的准确性

**个性化配置**：
- 支持用户自定义检测参数
- 支持用户添加白名单
- 提高灵活性

## 十二、总结

本方案设计了一个针对LLM流式生成死循环的检测系统，具有以下特点：

1. **针对性强**：仅检测reasoningMessage，避免对正常内容造成误判
2. **分类型检测**：针对三种不同类型的死循环，采用不同的检测策略
3. **代码复用**：类型1和类型2共用通用周期检测逻辑，避免重复实现
4. **性能优化**：通过检查点机制，将检测开销降至最低
5. **误判防范**：通过合理的阈值设置和边界处理，降低误判率
6. **易于实现**：检测逻辑清晰，集成简单，便于维护
7. **可扩展性**：参数可配置，支持后续优化和增强

该方案在保证较高准确率的同时，将性能开销降至最低，且易于实现和维护，能够有效拦截LLM生成中的典型死循环情况。通过提取通用周期检测逻辑，进一步提高了代码的可维护性和可扩展性。
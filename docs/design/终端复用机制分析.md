# Roo-Code 终端复用机制分析

## 概述

Roo-Code 项目通过 `TerminalRegistry` 单例类管理终端的生命周期和复用，支持在执行命令时智能复用已有终端，特别是在 `cd` 操作后能正确识别终端的实际工作目录变化。

---

## 核心架构

### 组件关系图

```
┌─────────────────────────────────────────────────────────────────┐
│                      TerminalRegistry                            │
│  - terminals: RooTerminal[]                                     │
│  - getOrCreateTerminal(cwd, taskId, provider)                   │
│  - releaseTerminalsForTask(taskId)                              │
└─────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              │                               │
              ▼                               ▼
    ┌─────────────────┐            ┌─────────────────┐
    │    Terminal     │            │  ExecaTerminal  │
    │   (VSCode)      │            │   (execa)       │
    │                 │            │                 │
    │ - terminal      │            │ - 无 UI         │
    │ - shellIntegration│          │ - 始终返回     │
    │ - 动态 cwd       │            │   initialCwd   │
    └─────────────────┘            └─────────────────┘
              │                               │
              ▼                               ▼
    ┌─────────────────┐            ┌─────────────────┐
    │ TerminalProcess │            │ExecaTerminalProcess│
    │                 │            │                 │
    │ - 流式输出处理   │            │ - 直接执行     │
    │ - shell integration│          │ - 无 shell     │
    │   标记解析       │            │   integration  │
    └─────────────────┘            └─────────────────┘
```

### 关键类说明

| 类名 | 类型 | 工作目录获取方式 | Shell Integration |
|------|------|------------------|-------------------|
| `Terminal` | VSCode 终端 | 动态 (`shellIntegration.cwd`) | 支持 |
| `ExecaTerminal` | 后台进程 | 静态 (`initialCwd`) | 不支持 |

---

## 终端复用决策树

### 完整条件分支树

```
getOrCreateTerminal(cwd, taskId, provider)
│
├─ 步骤 1: 清理已关闭的终端
│  └─ this.terminals = this.terminals.filter(t => !t.isClosed())
│
├─ 步骤 2: 第一优先级查找（任务绑定终端）
│  │
│  └─ 查找条件（全部满足）:
│     ├─ t.busy === false                    [终端空闲]
│     ├─ t.taskId === taskId                 [绑定到当前任务]
│     ├─ t.provider === provider             [提供者类型匹配]
│     └─ arePathsEqual(t.getCurrentWorkingDirectory(), cwd) [工作目录匹配]
│     │
│     ├─ ✓ 找到 → 返回该终端
│     └─ ✗ 未找到 → 进入步骤 3
│
├─ 步骤 3: 第二优先级查找（任意空闲终端）
│  │
│  └─ 查找条件（全部满足）:
│     ├─ t.busy === false                    [终端空闲]
│     ├─ t.provider === provider             [提供者类型匹配]
│     └─ arePathsEqual(t.getCurrentWorkingDirectory(), cwd) [工作目录匹配]
│     │
│     ├─ ✓ 找到 → 返回该终端
│     └─ ✗ 未找到 → 进入步骤 4
│
└─ 步骤 4: 创建新终端
   │
   ├─ provider === "vscode"
   │  └─ new Terminal(id, undefined, cwd)
   │     └─ vscode.window.createTerminal({ cwd, env, ... })
   │
   └─ provider === "execa"
      └─ new ExecaTerminal(id, cwd)
         └─ 仅记录初始 cwd，不创建实际终端
```

### 决策树代码实现

```typescript
// TerminalRegistry.ts - getOrCreateTerminal 方法
public static async getOrCreateTerminal(
    cwd: string,
    taskId?: string,
    provider: RooTerminalProvider = "vscode",
): Promise<RooTerminal> {
    const terminals = this.getAllTerminals()
    let terminal: RooTerminal | undefined

    // ========== 第一优先级：任务绑定终端 ==========
    if (taskId) {
        terminal = terminals.find((t) => {
            if (t.busy || t.taskId !== taskId || t.provider !== provider) {
                return false
            }
            const terminalCwd = t.getCurrentWorkingDirectory()
            if (!terminalCwd) {
                return false
            }
            return arePathsEqual(vscode.Uri.file(cwd).fsPath, terminalCwd)
        })
    }

    // ========== 第二优先级：任意空闲终端 ==========
    if (!terminal) {
        terminal = terminals.find((t) => {
            if (t.busy || t.provider !== provider) {
                return false
            }
            const terminalCwd = t.getCurrentWorkingDirectory()
            if (!terminalCwd) {
                return false
            }
            return arePathsEqual(vscode.Uri.file(cwd).fsPath, terminalCwd)
        })
    }

    // ========== 第三步：创建新终端 ==========
    if (!terminal) {
        terminal = this.createTerminal(cwd, provider)
    }

    terminal.taskId = taskId
    return terminal
}
```

---

## `cd` 操作后的终端复用机制

### 工作流程

```
时间线:
│
├─ T1: 任务 A 启动，cwd = /project
│   └─ 创建 Terminal-1
│      - taskId: A
│      - initialCwd: /project
│      - getCurrentWorkingDirectory(): /project
│
├─ T2: 执行命令 `cd src`
│   └─ VSCode shell integration 更新 terminal.shellIntegration.cwd
│      - terminal.shellIntegration.cwd.fsPath: /project/src
│
├─ T3: 任务 A 再次执行命令，cwd = /project/src
│   │
│   ├─ 调用 getOrCreateTerminal("/project/src", "A", "vscode")
│   │
│   ├─ 第一优先级查找:
│   │  ├─ Terminal-1.busy === false? ✓
│   │  ├─ Terminal-1.taskId === "A"? ✓
│   │  ├─ Terminal-1.provider === "vscode"? ✓
│   │  └─ arePathsEqual(Terminal-1.getCurrentWorkingDirectory(), "/project/src")?
│   │     └─ terminal.shellIntegration.cwd.fsPath === "/project/src"? ✓
│   │
│   └─ 结果：复用 Terminal-1
│
└─ T4: 任务 A 执行命令，cwd = /project
    │
    ├─ 调用 getOrCreateTerminal("/project", "A", "vscode")
    │
    ├─ 第一优先级查找:
    │  └─ arePathsEqual("/project/src", "/project")? ✗
    │
    └─ 结果：创建 Terminal-2 (taskId: A, cwd: /project)
```

### 工作目录获取实现

#### VSCode Terminal（动态）

```typescript
// Terminal.ts
public override getCurrentWorkingDirectory(): string {
    return this.terminal.shellIntegration?.cwd 
        ? this.terminal.shellIntegration.cwd.fsPath 
        : this.initialCwd
}
```

**关键点：**
- 优先使用 `shellIntegration.cwd`（实时获取）
- 降级到 `initialCwd`（shell integration 不可用时）

#### ExecaTerminal（静态）

```typescript
// BaseTerminal.ts
public getCurrentWorkingDirectory(): string {
    return this.initialCwd
}
```

**关键点：**
- 始终返回初始目录
- 适用于无 UI 的后台命令执行

---

## 终端状态管理

### 状态属性

```typescript
interface RooTerminal {
    provider: RooTerminalProvider      // "vscode" | "execa"
    id: number                         // 唯一标识符
    busy: boolean                      // 是否正在执行命令
    running: boolean                   // shell 是否正在运行
    taskId?: string                    // 关联的任务 ID
    process?: RooTerminalProcess       // 当前活动进程
    completedProcesses: RooTerminalProcess[]  // 已完成的进程队列
}
```

### 状态流转图

```
                    ┌──────────────┐
                    │   新终端创建   │
                    │ busy=false   │
                    │ running=false│
                    │ taskId=undef │
                    └──────┬───────┘
                           │
                           ▼
              ┌────────────────────────┐
              │ getOrCreateTerminal    │
              │ 设置 taskId            │
              └───────────┬────────────┘
                          │
                          ▼
              ┌────────────────────────┐
              │ runCommand(command)    │
              │ busy=true              │
              │ running=true           │
              │ process=新进程          │
              └───────────┬────────────┘
                          │
                          ▼
              ┌────────────────────────┐
              │ onDidStartTerminal     │
              │ shellExecution         │
              │ running=true           │
              └───────────┬────────────┘
                          │
                          ▼
              ┌────────────────────────┐
              │ onDidEndTerminal       │
              │ shellExecution         │
              │ busy=false             │
              │ running=false          │
              │ process→completedQueue │
              └───────────┬────────────┘
                          │
                          ▼
              ┌────────────────────────┐
              │ releaseTerminalsForTask│
              │ taskId=undefined       │
              └────────────────────────┘
```

---

## Shell Integration 机制

### VSCode Shell Integration 事件

```typescript
// TerminalRegistry.initialize()

// 1. 终端关闭事件
vscode.window.onDidCloseTerminal((vsceTerminal) => {
    const terminal = this.getTerminalByVSCETerminal(vsceTerminal)
    if (terminal) {
        ShellIntegrationManager.zshCleanupTmpDir(terminal.id)
    }
})

// 2. Shell 执行开始事件
vscode.window.onDidStartTerminalShellExecution?.(async (e) => {
    const stream = e.execution.read()
    const terminal = this.getTerminalByVSCETerminal(e.terminal)
    
    if (terminal) {
        terminal.setActiveStream(stream)
        terminal.busy = true  // 标记为忙
    }
})

// 3. Shell 执行结束事件
vscode.window.onDidEndTerminalShellExecution?.(async (e) => {
    const terminal = this.getTerminalByVSCETerminal(e.terminal)
    
    if (terminal && terminal.running) {
        terminal.shellExecutionComplete(exitDetails)
        terminal.busy = false  // 标记为空闲
    }
})
```

### Shell Integration 标记

VSCode 使用自定义 OSC 633 序列标记命令边界：

```
\x1b]633;A\x07  - Mark prompt start（提示符开始）
\x1b]633;B\x07  - Mark prompt end（提示符结束）
\x1b]633;C\x07  - Mark pre-execution（命令开始）
\x1b]633;D;0\x07 - Mark execution finished（命令结束，带退出码）
```

### 输出处理流程

```typescript
// TerminalProcess.run()

for await (let data of stream) {
    // 1. 等待命令输出开始标记 (C)
    if (!commandOutputStarted) {
        preOutput += data
        const match = this.matchAfterVsceStartMarkers(data)
        if (match !== undefined) {
            commandOutputStarted = true
            data = match
            this.fullOutput = ""
        } else {
            continue
        }
    }
    
    // 2. 累积命令输出
    this.fullOutput += data
    
    // 3. 增量发射输出到 UI
    if (this.isListening && (now - this.lastEmitTime_ms > 100)) {
        this.emitRemainingBufferIfListening()
    }
}

// 4. 等待 shell 执行完成
await shellExecutionComplete

// 5. 移除结束标记 (D)
const match = this.matchBeforeVsceEndMarkers(this.fullOutput)
if (match !== undefined) {
    this.fullOutput = match
}

// 6. 发射完成事件
this.emit("completed", this.removeEscapeSequences(this.fullOutput))
```

---

## 任务生命周期管理

### 终端与任务绑定

```typescript
// ExecuteCommandTool.executeCommandInTerminal()

// 1. 获取或创建终端（绑定 taskId）
const terminal = await TerminalRegistry.getOrCreateTerminal(
    workingDir, 
    task.taskId,  // 任务 ID
    terminalProvider
)

// 2. 执行命令
const process = terminal.runCommand(command, callbacks)
task.terminalProcess = process

// 3. 等待完成
await process

// 4. 任务结束时释放终端
// TaskLifecycleManager.ts
TerminalRegistry.releaseTerminalsForTask(this.taskId)
```

### 终端释放逻辑

```typescript
// TerminalRegistry.releaseTerminalsForTask()
public static releaseTerminalsForTask(taskId: string): void {
    this.terminals.forEach((terminal) => {
        if (terminal.taskId === taskId) {
            terminal.taskId = undefined  // 解除绑定
        }
    })
}
```

**效果：**
- 释放后，终端变为"背景终端"（taskId 为 undefined）
- 背景终端可被其他任务复用（第二优先级查找）
- 背景终端的输出仍可通过 `getBackgroundTerminals()` 获取

---

## 环境详情收集

### 获取终端状态

```typescript
// getEnvironmentDetails.ts

// 获取任务专用终端
const busyTerminals = [
    ...TerminalRegistry.getTerminals(true, cline.taskId),   // 忙碌的任务终端
    ...TerminalRegistry.getBackgroundTerminals(true),       // 忙碌的背景终端
]

const inactiveTerminals = [
    ...TerminalRegistry.getTerminals(false, cline.taskId),  // 空闲的任务终端
    ...TerminalRegistry.getBackgroundTerminals(false),      // 空闲的背景终端
]

// 收集输出信息
for (const busyTerminal of busyTerminals) {
    const cwd = busyTerminal.getCurrentWorkingDirectory()
    details += `\n## Terminal ${busyTerminal.id} (Active)`
    details += `\n### Working Directory: \`${cwd}\``
    details += `\n### Original command: \`${busyTerminal.getLastCommand()}\``
    
    let newOutput = TerminalRegistry.getUnretrievedOutput(busyTerminal.id)
    if (newOutput) {
        details += `\n### New Output\n${newOutput}`
    }
}
```

### 终端冷却机制

```typescript
// 等待终端冷却（避免输出不完整）
if (busyTerminals.length > 0) {
    if (cline.didEditFile) {
        await delay(300)  // 文件编辑后等待
    }
    
    await pWaitFor(
        () => busyTerminals.every((t) => !TerminalRegistry.isProcessHot(t.id)),
        { interval: 100, timeout: 5_000 }
    )
}
```

---

## 配置选项

### 终端相关设置

| 设置项 | 默认值 | 说明 |
|--------|--------|------|
| `terminal.shellIntegrationDisabled` | `true` | 禁用 shell integration（使用 execa 后备） |
| `terminal.shellIntegrationTimeout` | `5000` | Shell integration 超时时间（毫秒） |
| `terminal.commandDelay` | `0` | 命令执行延迟（解决 VSCode bug） |
| `terminal.outputLineLimit` | `500` | 输出行数限制 |
| `terminal.outputCharacterLimit` | `50000` | 输出字符限制 |
| `terminal.powershellCounter` | `false` | PowerShell 计数器工作区 |
| `terminal.zshClearEolMark` | `true` | 清除 ZSH 行尾标记 |
| `terminal.zshOhMy` | `false` | Oh My Zsh 集成 |
| `terminal.zshP10k` | `false` | Powerlevel10k 集成 |
| `terminal.zdotdir` | `false` | ZDOTDIR 处理 |
| `terminal.compressProgressBar` | `true` | 压缩进度条输出 |

### 环境变量设置

```typescript
// Terminal.getEnv()
const env: Record<string, string> = {
    PAGER: process.platform === "win32" ? "" : "cat",
    VTE_VERSION: "0",  // 禁用 VTE
}

// Oh My Zsh
if (Terminal.getTerminalZshOhMy()) {
    env.ITERM_SHELL_INTEGRATION_INSTALLED = "Yes"
}

// Powerlevel10k
if (Terminal.getTerminalZshP10k()) {
    env.POWERLEVEL9K_TERM_SHELL_INTEGRATION = "true"
}

// 命令延迟
if (Terminal.getCommandDelay() > 0) {
    env.PROMPT_COMMAND = `sleep ${Terminal.getCommandDelay() / 1000}`
}

// ZSH 行尾标记
if (Terminal.getTerminalZshClearEolMark()) {
    env.PROMPT_EOL_MARK = ""
}

// ZDOTDIR
if (Terminal.getTerminalZdotdir()) {
    env.ZDOTDIR = ShellIntegrationManager.zshInitTmpDir(env)
}
```

---

## 路径比较工具

### 跨平台路径比较

```typescript
// utils/path.ts
export function arePathsEqual(path1?: string, path2?: string): boolean {
    if (!path1 && !path2) return true
    if (!path1 || !path2) return false

    path1 = normalizePath(path1)
    path2 = normalizePath(path2)

    // Windows 不区分大小写
    if (process.platform === "win32") {
        return path1.toLowerCase() === path2.toLowerCase()
    }
    
    // POSIX 区分大小写
    return path1 === path2
}

function normalizePath(p: string): string {
    let normalized = path.normalize(p)  // 解析 ./.. 和重复斜杠
    // 移除尾随斜杠（根路径除外）
    if (normalized.length > 1 && (normalized.endsWith("/") || normalized.endsWith("\\"))) {
        normalized = normalized.slice(0, -1)
    }
    return normalized
}
```

---

## 典型场景分析

### 场景 1：连续 cd 操作

```
初始状态：无终端

1. execute_command("cd /app", cwd="/")
   → 创建 Terminal-1 (taskId=A, cwd="/")
   → 执行后 shellIntegration.cwd = "/app"

2. execute_command("ls", cwd="/app")
   → 查找：Terminal-1.getCurrentWorkingDirectory() === "/app"? ✓
   → 复用 Terminal-1

3. execute_command("pwd", cwd="/")
   → 查找：Terminal-1.getCurrentWorkingDirectory() === "/"? ✗
   → 创建 Terminal-2 (taskId=A, cwd="/")
```

### 场景 2：多任务并发

```
任务 A 和任务 B 同时运行

1. 任务 A: execute_command("npm install", cwd="/project")
   → 创建 Terminal-1 (taskId=A, cwd="/project")
   → Terminal-1.busy = true

2. 任务 B: execute_command("ls", cwd="/project")
   → 第一优先级：taskId 不匹配 ✗
   → 第二优先级：Terminal-1.busy === true ✗
   → 创建 Terminal-2 (taskId=B, cwd="/project")

3. 任务 A 完成
   → releaseTerminalsForTask("A")
   → Terminal-1.taskId = undefined（变为背景终端）

4. 任务 B: execute_command("cat file", cwd="/project")
   → 第一优先级：无匹配 ✗
   → 第二优先级：Terminal-1.busy === false, cwd 匹配 ✓
   → 复用 Terminal-1（现在绑定到任务 B）
```

### 场景 3：Shell Integration 失败

```
1. execute_command("ls", cwd="/project")
   → 等待 shellIntegration (超时 5000ms)
   → 超时：emit("no_shell_integration")
   → 降级到 execa provider
   
2. 后续命令
   → 使用 ExecaTerminal（无 shell integration）
   → getCurrentWorkingDirectory() 始终返回 initialCwd
```

---

## 关键设计决策

### 1. 为什么使用两步查找？

- **第一优先级（任务绑定）**：确保同一任务的命令尽可能使用同一终端，保持状态一致性
- **第二优先级（任意空闲）**：提高终端利用率，避免创建过多终端

### 2. 为什么需要 `busy` 状态？

- 防止命令交错执行
- 确保 `getOrCreateTerminal` 返回的终端立即可用
- 配合 VSCode shell execution 事件自动管理

### 3. 为什么支持两种 Provider？

- **VSCode Terminal**：完整 shell integration，支持实时输出、工作目录跟踪
- **ExecaTerminal**：轻量级后备方案，适用于 shell integration 不可用的场景

### 4. 为什么需要终端冷却？

- VSCode 终端输出可能有延迟
- 文件保存后终端可能需要时间更新
- 确保环境详情收集时输出完整

---

## 相关文件索引

| 文件路径 | 职责 |
|----------|------|
| `src/integrations/terminal/TerminalRegistry.ts` | 终端注册表，复用逻辑 |
| `src/integrations/terminal/Terminal.ts` | VSCode 终端封装 |
| `src/integrations/terminal/ExecaTerminal.ts` | Execa 终端封装 |
| `src/integrations/terminal/TerminalProcess.ts` | VSCode 终端进程 |
| `src/integrations/terminal/ExecaTerminalProcess.ts` | Execa 终端进程 |
| `src/integrations/terminal/BaseTerminal.ts` | 终端基类 |
| `src/integrations/terminal/ShellIntegrationManager.ts` | Shell integration 管理 |
| `src/core/tools/ExecuteCommandTool.ts` | 命令执行工具 |
| `src/core/environment/getEnvironmentDetails.ts` | 环境详情收集 |
| `src/core/task/managers/core/TaskLifecycleManager.ts` | 任务生命周期管理 |
| `src/utils/path.ts` | 路径工具函数 |

---

## 总结

Roo-Code 的终端复用机制核心在于：

1. **动态工作目录检测**：通过 VSCode shell integration 实时获取终端的实际工作目录
2. **优先级查找策略**：先找任务绑定终端，再找任意空闲终端
3. **状态驱动管理**：通过 `busy`、`running`、`taskId` 等状态精确控制终端生命周期
4. **优雅降级**：shell integration 不可用时自动切换到 execa 后备方案

这使得在执行 `cd` 等改变工作目录的命令后，系统能正确识别终端的实际状态并做出合理的复用决策。

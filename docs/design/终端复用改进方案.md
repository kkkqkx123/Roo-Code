# 终端复用机制改进方案

## 问题分析

### 当前问题

根据 `docs/design/终端复用机制分析.md` 的分析，当前终端复用机制存在以下问题：

**场景重现：**
```
1. 任务 A 在 /project 目录执行命令
   → 创建 Terminal-1 (taskId=A, cwd=/project)

2. 执行 cd src 命令
   → Terminal-1 的 shellIntegration.cwd 更新为 /project/src

3. 任务 A 再次执行命令，请求 cwd=/project
   → 查找：Terminal-1.getCurrentWorkingDirectory() === /project? ✗
   → 结果：创建 Terminal-2 (taskId=A, cwd=/project)
```

**问题根源：**
- [`TerminalRegistry.getOrCreateTerminal()`](src/integrations/terminal/TerminalRegistry.ts:152) 中的查找逻辑过于严格
- 要求 `arePathsEqual(t.getCurrentWorkingDirectory(), cwd)` 必须完全匹配
- 没有考虑终端可以通过 `cd` 命令切换目录的能力

### 影响范围

- **终端数量爆炸**：每次 cd 后切换回原目录都会创建新终端
- **资源浪费**：大量空闲终端占用内存和 VSCode 终端面板空间
- **用户体验差**：终端面板显示过多终端，难以管理

## 改进方案

### 核心思路

**智能终端复用策略**：不仅考虑终端当前目录，还考虑终端能否通过 `cd` 命令切换到目标目录。

### 设计原则

1. **优先完全匹配**：完全匹配的终端优先级最高
2. **支持目录切换**：允许复用可以切换到目标目录的终端
3. **保持任务绑定**：同一任务的终端优先复用
4. **避免过度复用**：限制终端切换次数，防止终端状态混乱

### 实现方案

#### 1. 添加路径关系判断函数

在 `src/utils/path.ts` 中添加新函数：

```typescript
/**
 * 判断两个路径的关系
 * @returns 'same' - 相同路径
 *          'parent' - path1 是 path2 的父目录
 *          'child' - path1 是 path2 的子目录
 *          'unrelated' - 无关路径
 */
export function getPathRelation(path1: string, path2: string): PathRelation

/**
 * 检查路径是否可以切换到目标路径
 * @returns true 如果可以通过 cd 命令从 currentPath 切换到 targetPath
 */
export function canChangeDirectory(currentPath: string, targetPath: string): boolean
```

#### 2. 优化终端查找逻辑

修改 [`TerminalRegistry.getOrCreateTerminal()`](src/integrations/terminal/TerminalRegistry.ts:152)：

```typescript
// 第一优先级：任务绑定终端（完全匹配）
if (taskId) {
    terminal = terminals.find((t) => {
        if (t.busy || t.taskId !== taskId || t.provider !== provider) {
            return false
        }
        const terminalCwd = t.getCurrentWorkingDirectory()
        if (!terminalCwd) {
            return false
        }
        return arePathsEqual(vscode.Uri.file(cwd).fsPath, terminalCwd)
    })
}

// 第二优先级：任务绑定终端（可切换）
if (!terminal && taskId) {
    terminal = terminals.find((t) => {
        if (t.busy || t.taskId !== taskId || t.provider !== provider) {
            return false
        }
        const terminalCwd = t.getCurrentWorkingDirectory()
        if (!terminalCwd) {
            return false
        }
        return canChangeDirectory(terminalCwd, cwd)
    })
}

// 第三优先级：任意空闲终端（完全匹配）
if (!terminal) {
    terminal = terminals.find((t) => {
        if (t.busy || t.provider !== provider) {
            return false
        }
        const terminalCwd = t.getCurrentWorkingDirectory()
        if (!terminalCwd) {
            return false
        }
        return arePathsEqual(vscode.Uri.file(cwd).fsPath, terminalCwd)
    })
}

// 第四优先级：任意空闲终端（可切换）
if (!terminal) {
    terminal = terminals.find((t) => {
        if (t.busy || t.provider !== provider) {
            return false
        }
        const terminalCwd = t.getCurrentWorkingDirectory()
        if (!terminalCwd) {
            return false
        }
        return canChangeDirectory(terminalCwd, cwd)
    })
}
```

#### 3. 添加终端切换追踪

在 `BaseTerminal` 中添加切换计数：

```typescript
export abstract class BaseTerminal implements RooTerminal {
    // ... 现有属性

    /**
     * 记录该终端被复用时需要 cd 切换目录的次数
     * 用于防止终端被过度复用导致状态混乱
     */
    public directoryChangeCount: number = 0

    /**
     * 增加目录切换计数
     */
    public incrementDirectoryChangeCount(): void {
        this.directoryChangeCount++
    }

    /**
     * 检查是否应该继续复用该终端
     * 如果切换次数过多，建议创建新终端
     */
    public shouldReuseForDirectoryChange(): boolean {
        // 限制最多切换 5 次，超过后建议创建新终端
        return this.directoryChangeCount < 5
    }
}
```

#### 4. 在执行命令前自动切换目录

修改 [`ExecuteCommandTool.executeCommandInTerminal()`](src/core/tools/ExecuteCommandTool.ts:148)：

```typescript
const terminal = await TerminalRegistry.getOrCreateTerminal(workingDir, task.taskId, terminalProvider)

// 检查是否需要切换目录
const terminalCwd = terminal.getCurrentWorkingDirectory()
if (!arePathsEqual(terminalCwd, workingDir)) {
    // 需要切换目录
    terminal.incrementDirectoryChangeCount()

    // 如果切换次数过多，创建新终端
    if (!terminal.shouldReuseForDirectoryChange()) {
        const newTerminal = await TerminalRegistry.createTerminal(workingDir, terminalProvider)
        newTerminal.taskId = task.taskId
        // 使用新终端
        // ...
    } else {
        // 在命令前添加 cd 命令
        const cdCommand = `cd "${workingDir}" && ${command}`
        // 执行 cd 命令
        // ...
    }
}
```

### 实现细节

#### 路径关系判断实现

```typescript
export type PathRelation = 'same' | 'parent' | 'child' | 'unrelated'

export function getPathRelation(path1: string, path2: string): PathRelation {
    const normalized1 = normalizePath(path1)
    const normalized2 = normalizePath(path2)

    if (arePathsEqual(normalized1, normalized2)) {
        return 'same'
    }

    // 检查 path1 是否是 path2 的父目录
    if (normalized2.startsWith(normalized1 + path.sep)) {
        return 'parent'
    }

    // 检查 path1 是否是 path2 的子目录
    if (normalized1.startsWith(normalized2 + path.sep)) {
        return 'child'
    }

    return 'unrelated'
}

export function canChangeDirectory(currentPath: string, targetPath: string): boolean {
    const relation = getPathRelation(currentPath, targetPath)

    // 相同路径或父子关系都可以通过 cd 切换
    return relation === 'same' || relation === 'parent' || relation === 'child'
}
```

### 优势

1. **减少终端数量**：避免因 cd 操作创建过多终端
2. **提高资源利用率**：复用已有终端，减少内存占用
3. **保持用户体验**：终端面板更整洁，易于管理
4. **向后兼容**：完全匹配的终端优先级最高，不影响现有行为

### 风险与缓解

| 风险 | 缓解措施 |
|------|----------|
| 终端状态混乱 | 限制切换次数（最多 5 次） |
| 环境变量污染 | 每次切换前记录环境，必要时重置 |
| 命令执行失败 | 添加错误处理，失败时创建新终端 |
| 性能影响 | 路径判断使用字符串操作，性能开销小 |

### 测试策略

1. **单元测试**：测试路径关系判断函数
2. **集成测试**：测试终端复用逻辑
3. **场景测试**：模拟真实使用场景（连续 cd、多任务并发等）

## 实施计划

1. ✅ 分析问题根源
2. ✅ 设计改进方案
3. ⏳ 实现路径关系判断函数
4. ⏳ 优化终端查找逻辑
5. ⏳ 添加终端切换追踪
6. ⏳ 修改命令执行逻辑
7. ⏳ 编写测试用例
8. ⏳ 运行测试验证
9. ⏳ 更新文档

## 相关文件

- `src/utils/path.ts` - 添加路径关系判断函数
- `src/integrations/terminal/TerminalRegistry.ts` - 优化终端查找逻辑
- `src/integrations/terminal/BaseTerminal.ts` - 添加切换追踪
- `src/core/tools/ExecuteCommandTool.ts` - 修改命令执行逻辑
- `src/integrations/terminal/__tests__/path.spec.ts` - 路径工具测试
- `src/integrations/terminal/__tests__/TerminalRegistry.spec.ts` - 终端注册表测试
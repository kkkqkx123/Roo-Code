# 工具提示词集成分析

本文档分析 Coder 项目如何将工具相关提示词添加到系统提示词中。

## 概述

项目采用**分离式设计**：工具定义与系统提示词文本分离，通过模块化方式组合生成完整的系统提示词。

## 架构流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    SYSTEM_PROMPT 函数                            │
│                  (src/core/prompts/system.ts)                   │
└────────────────────────┬────────────────────────────────────────┘
                         │
         ┌───────────────┼───────────────┐
         │               │               │
         ▼               ▼               ▼
┌─────────────────┐ ┌──────────────────┐ ┌─────────────────────┐
│  提示词章节函数   │ │  工具定义构建     │ │   MCP 工具集成       │
│  (sections/)    │ │ (build-tools.ts) │ │  (mcp_server.ts)    │
└─────────────────┘ └──────────────────┘ └─────────────────────┘
         │               │               │
         │               │               │
         ▼               ▼               ▼
┌─────────────────────────────────────────────────────────────────┐
│                     最终系统提示词                                │
│  包含：角色定义 + 工具说明 + 使用指南 + 能力描述 + 自定义指令          │
└─────────────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. 系统提示词生成入口

**文件**: `src/core/prompts/system.ts`

```typescript
export const SYSTEM_PROMPT = async (
    context: vscode.ExtensionContext,
    cwd: string,
    supportsComputerUse: boolean,
    mcpHub?: McpHub,
    // ... 其他参数
): Promise<string> => {
    return generatePrompt(...)
}
```

**提示词组合结构**:

```typescript
const basePrompt = `${roleDefinition}                    // 角色定义

${markdownFormattingSection()}           // Markdown 格式说明

${getSharedToolUseSection()}             // 工具使用基础说明
${toolsCatalog}                          // 工具目录（当前为空）

${getToolUseGuidelinesSection()}         // 工具使用指南

${getCapabilitiesSection(cwd, mcpHub)}   // 能力说明（含工具能力）

${modesSection}                          // 模式说明
${skillsSection}                         // 技能说明

${getRulesSection(cwd, settings)}        // 规则部分

${getSystemInfoSection(cwd)}             // 系统信息

${getObjectiveSection()}                 // 目标部分

${await addCustomInstructions(...)}      // 自定义指令
`
```

### 2. 工具提示词章节

#### 2.1 工具使用基础说明

**文件**: `src/core/prompts/sections/tool-use.ts`

```typescript
export function getSharedToolUseSection(): string {
    return `====

TOOL USE

You have access to a set of tools that are executed upon the user's approval. 
Use the provider-native tool-calling mechanism. Do not include XML markup or examples. 
You must call at least one tool per assistant response. 
Prefer calling as many tools as are reasonably needed in a single response 
to reduce back-and-forth and complete tasks faster.`
}
```

#### 2.2 工具使用指南

**文件**: `src/core/prompts/sections/tool-use-guidelines.ts`

```typescript
export function getToolUseGuidelinesSection(): string {
    return `# Tool Use Guidelines

1. Assess what information you already have and what information you need to proceed with the task.
2. Choose the most appropriate tool based on the task and the tool descriptions provided.
3. If multiple actions are needed, you may use multiple tools in a single message when appropriate...
`
}
```

#### 2.3 能力说明（包含工具能力描述）

**文件**: `src/core/prompts/sections/capabilities.ts`

```typescript
export function getCapabilitiesSection(cwd: string, mcpHub?: McpHub): string {
    return `====

CAPABILITIES

- You have access to tools that let you execute CLI commands on the user's computer, 
  list files, view source code definitions, regex search, read and write files, 
  and ask follow-up questions.
- When the user initially gives you a task, a recursive list of all filepaths 
  in the current workspace directory will be included in environment_details...
- You can use the execute_command tool to run commands on the user's computer...
${mcpHub ? `- You have access to MCP servers that may provide additional tools and resources.` : ""}
`
}
```

### 3. 工具定义构建

**文件**: `src/core/task/build-tools.ts`

工具定义通过 `buildNativeToolsArray` 函数构建，用于 API 调用：

```typescript
export async function buildNativeToolsArray(options: BuildToolsOptions): Promise<OpenAI.Chat.ChatCompletionTool[]> {
    const { provider, cwd, mode, customModes, experiments, apiConfiguration, disabledTools, modelInfo } = options
    
    const mcpHub = provider.getMcpHub()
    
    // 1. 获取原生工具
    const nativeTools = getNativeTools({ supportsImages })
    
    // 2. 根据模式过滤原生工具
    const filteredNativeTools = filterNativeToolsForMode(
        nativeTools, mode, customModes, experiments, codeIndexManager, filterSettings, mcpHub
    )
    
    // 3. 获取并过滤 MCP 工具
    const mcpTools = getMcpServerTools(mcpHub)
    const filteredMcpTools = filterMcpToolsForMode(mcpTools, mode, customModes, experiments)
    
    // 4. 组合所有工具
    return [...filteredNativeTools, ...filteredMcpTools, ...nativeCustomTools]
}
```

### 4. 原生工具定义

**目录**: `src/core/prompts/tools/native-tools/`

每个工具有独立的定义文件，包含详细的 `description`：

#### 示例：execute_command.ts

```typescript
import type OpenAI from "openai"

const EXECUTE_COMMAND_DESCRIPTION = `Request to execute a CLI command on the system. 
Use this when you need to perform system operations or run specific commands...

Parameters:
- command: (required) The CLI command to execute.
- cwd: (optional) The working directory to execute the command in

Example: Executing npm run dev
{ "command": "npm run dev", "cwd": null }
`

export default {
    type: "function",
    function: {
        name: "execute_command",
        description: EXECUTE_COMMAND_DESCRIPTION,
        strict: true,
        parameters: {
            type: "object",
            properties: {
                command: { type: "string", description: "Shell command to execute" },
                cwd: { type: ["string", "null"], description: "Optional working directory" }
            },
            required: ["command", "cwd"],
            additionalProperties: false
        }
    }
} satisfies OpenAI.Chat.ChatCompletionTool
```

#### 示例：read_file.ts

```typescript
export function createReadFileTool(options: ReadFileToolOptions = {}): OpenAI.Chat.ChatCompletionTool {
    const { supportsImages = false } = options
    
    const descriptionIntro = "Read a file and return its contents with line numbers..."
    const modeDescription = "Supports two modes: 'slice' (default) and 'indentation'..."
    const limitNote = `By default, returns up to ${DEFAULT_LINE_LIMIT} lines per file...`
    
    const description = descriptionIntro + modeDescription + limitNote + 
                       getReadFileSupportsNote(supportsImages)
    
    return {
        type: "function",
        function: {
            name: "read_file",
            description: description,
            parameters: { ... }
        }
    }
}
```

### 5. MCP 工具动态集成

**文件**: `src/core/prompts/tools/native-tools/mcp_server.ts`

MCP 工具在运行时动态生成：

```typescript
export function getMcpServerTools(mcpHub?: McpHub): OpenAI.Chat.ChatCompletionTool[] {
    if (!mcpHub) return []
    
    const servers = mcpHub.getServers()
    const tools: OpenAI.Chat.ChatCompletionTool[] = []
    const seenToolNames = new Set<string>()
    
    for (const server of servers) {
        if (!server.tools) continue
        
        for (const tool of server.tools) {
            // 过滤：只包含 enabledForPrompt !== false 的工具
            if (tool.enabledForPrompt === false) continue
            
            const toolName = buildMcpToolName(server.name, tool.name)
            
            if (seenToolNames.has(toolName)) continue
            seenToolNames.add(toolName)
            
            // 规范化 JSON Schema
            const parameters = normalizeToolSchema(tool.inputSchema)
            
            const toolDefinition: OpenAI.Chat.ChatCompletionTool = {
                type: "function",
                function: {
                    name: toolName,
                    description: tool.description,  // 使用 MCP 工具的 description
                    parameters: parameters
                }
            }
            
            tools.push(toolDefinition)
        }
    }
    
    return tools
}
```

### 6. 工具过滤机制

**文件**: `src/core/prompts/tools/filter-tools-for-mode.ts`

工具根据以下规则过滤：

```typescript
export function filterNativeToolsForMode(
    nativeTools: OpenAI.Chat.ChatCompletionTool[],
    mode: string | undefined,
    customModes: ModeConfig[] | undefined,
    experiments: Record<string, boolean> | undefined,
    codeIndexManager?: CodeIndexManager,
    settings?: Record<string, any>,
    mcpHub?: McpHub,
): OpenAI.Chat.ChatCompletionTool[] {
    
    // 1. 获取模式配置
    const modeConfig = getModeBySlug(modeSlug, customModes)
    
    // 2. 获取该模式允许的工具组
    const allToolsForMode = getToolsForMode(modeConfig.groups)
    
    // 3. 应用工具验证
    let allowedToolNames = new Set(
        allToolsForMode.filter((tool) =>
            isToolAllowedForMode(tool, modeSlug, customModes, ...)
        )
    )
    
    // 4. 应用模型自定义（excludedTools/includedTools）
    const { allowedTools, aliasRenames } = applyModelToolCustomization(
        allowedToolNames, modeConfig, modelInfo
    )
    
    // 5. 条件排除
    if (!codeIndexManager?.isFeatureEnabled) {
        allowedToolNames.delete("codebase_search")
    }
    if (settings?.todoListEnabled === false) {
        allowedToolNames.delete("update_todo_list")
    }
    if (!experiments?.imageGeneration) {
        allowedToolNames.delete("generate_image")
    }
    if (!mcpHub || !hasAnyMcpResources(mcpHub)) {
        allowedToolNames.delete("access_mcp_resource")
    }
    
    // 6. 过滤工具并应用别名重命名
    const filteredTools = nativeTools.filter(tool => {
        const toolName = tool.function.name
        if (allowedToolNames.has(toolName)) {
            const aliasName = aliasRenames.get(toolName)
            if (aliasName) {
                return getOrCreateRenamedTool(tool, aliasName)
            }
            return tool
        }
    })
    
    return filteredTools
}
```

## 工具提示词层次结构

```
┌─────────────────────────────────────────────────────────────┐
│ Layer 1: 通用工具说明 (所有模式共享)                          │
│ - getSharedToolUseSection()                                 │
│ - getToolUseGuidelinesSection()                             │
└─────────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│ Layer 2: 能力描述 (包含工具能力概览)                           │
│ - getCapabilitiesSection()                                  │
│   • 列出工具类别（CLI、文件、搜索等）                            │
│   • 动态包含 MCP 服务器说明                                     │
└─────────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│ Layer 3: 工具定义 (传递给 API)                                │
│ - buildNativeToolsArray()                                   │
│   • 原生工具：getNativeTools()                               │
│   • MCP 工具：getMcpServerTools()                             │
│   • 自定义工具：customToolRegistry                           │
└─────────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│ Layer 4: 工具过滤 (根据模式/设置/实验)                         │
│ - filterNativeToolsForMode()                                │
│ - filterMcpToolsForMode()                                   │
└─────────────────────────────────────────────────────────────┘
```

## 关键设计特点

### 1. 分离式设计
- **提示词文本** (`src/core/prompts/sections/`)：人类可读的说明
- **工具定义** (`src/core/prompts/tools/`)：API 使用的结构化定义
- **工具描述**：作为两者之间的桥梁，模型通过 description 理解工具用途

### 2. 动态工具生成
- MCP 工具在运行时从连接的服务器动态获取
- 支持 `enabledForPrompt` 标志控制工具是否出现在提示词中

### 3. 多层次过滤
| 过滤层级 | 依据 | 实现 |
|---------|------|------|
| 模式过滤 | 模式配置的工具组 | `getToolsForMode()` |
| 功能过滤 | 功能启用状态 | `codeIndexManager`, `experiments` |
| 设置过滤 | 用户设置 | `disabledTools`, `todoListEnabled` |
| 模型过滤 | 模型能力 | `modelInfo.excludedTools/includedTools` |

### 4. 工具别名支持
```typescript
// 定义在 src/core/prompts/tools/filter-tools-for-mode.ts
export const TOOL_ALIASES: Record<string, string> = {
    "search_and_replace": "edit",
    // ...
}

// 支持通过别名重命名工具
const aliasRenames = new Map<string, string>()
aliasRenames.set("edit", "search_and_replace")  // 将 edit 重命名为别名
```

### 5. 工具描述即提示词
工具的 `description` 字段是模型理解工具用途的主要方式：

```typescript
// 工具定义中的 description 会直接传递给 LLM
{
    type: "function",
    function: {
        name: "execute_command",
        description: "Request to execute a CLI command...",  // ← 这就是提示词
        parameters: {...}
    }
}
```

## 相关文件索引

| 文件路径 | 职责 |
|---------|------|
| `src/core/prompts/system.ts` | 系统提示词主入口 |
| `src/core/prompts/sections/*.ts` | 提示词章节函数 |
| `src/core/task/build-tools.ts` | 工具定义构建 |
| `src/core/prompts/tools/native-tools/*.ts` | 原生工具定义 |
| `src/core/prompts/tools/native-tools/mcp_server.ts` | MCP 工具集成 |
| `src/core/prompts/tools/filter-tools-for-mode.ts` | 工具过滤逻辑 |
| `src/shared/modes.ts` | 模式与工具组映射 |
| `src/shared/tools.ts` | 工具组定义常量 |

## 总结

Coder 项目通过以下方式将工具提示词集成到系统提示词中：

1. **文本说明**：通过 `getSharedToolUseSection()`、`getToolUseGuidelinesSection()`、`getCapabilitiesSection()` 提供工具使用的文本说明

2. **工具定义**：通过 `buildNativeToolsArray()` 构建结构化工具定义，包含详细的 `description`

3. **动态集成**：MCP 工具在运行时动态生成并集成

4. **智能过滤**：根据模式、设置、实验标志、模型能力等多维度过滤工具

5. **描述即提示**：工具的 `description` 字段作为模型理解工具的核心提示词
